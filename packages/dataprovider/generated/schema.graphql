### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


type BatchPayload {
  count: Int!
}

input BooleanFilter {
  equals: Boolean
  not: Boolean
}

enum Gender {
  FEMALE
  MALE
  OTHER
}

type Mutation {
  createOneUser(data: UserCreateInput!): User!
  createOneUserRole(data: UserRoleCreateInput!): UserRole!
  deleteManyUser(where: UserWhereInput): BatchPayload!
  deleteManyUserRole(where: UserRoleWhereInput): BatchPayload!
  deleteOneUser(where: UserWhereUniqueInput!): User
  deleteOneUserRole(where: UserRoleWhereUniqueInput!): UserRole
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updateManyUserRole(data: UserRoleUpdateManyMutationInput!, where: UserRoleWhereInput): BatchPayload!
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateOneUserRole(data: UserRoleUpdateInput!, where: UserRoleWhereUniqueInput!): UserRole
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  upsertOneUserRole(create: UserRoleCreateInput!, update: UserRoleUpdateInput!, where: UserRoleWhereUniqueInput!): UserRole!
}

input NullableIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

enum OrderByArg {
  asc
  desc
}

type Query {
  user(where: UserWhereUniqueInput!): User
  userRole(where: UserRoleWhereUniqueInput!): UserRole
  userRoles(after: UserRoleWhereUniqueInput, before: UserRoleWhereUniqueInput, first: Int, last: Int, orderBy: UserRoleOrderByInput, skip: Int, where: UserRoleWhereInput): [UserRole!]!
  userRolesCount: Int!
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): [User!]!
  usersCount: Int!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type User {
  email: String!
  firstName: String
  gender: Gender
  id: String!
  lastName: String
  logs(from: String!, to: String!): [String!]!
  roles(after: UserRoleWhereUniqueInput, before: UserRoleWhereUniqueInput, first: Int, last: Int, skip: Int, where: UserRoleWhereInput): [UserRole!]!
  wantsNewsletter: Boolean!
  yearOfBirth: Int
}

input UserCreateInput {
  email: String!
  firstName: String
  gender: Gender
  id: String
  lastName: String
  roles: UserRoleCreateManyWithoutUsersInput
  wantsNewsletter: Boolean!
  yearOfBirth: Int
}

input UserCreateManyWithoutRolesInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutRolesInput!]
}

input UserCreateWithoutRolesInput {
  email: String!
  firstName: String
  gender: Gender
  id: String
  lastName: String
  wantsNewsletter: Boolean!
  yearOfBirth: Int
}

input UserFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

input UserOrderByInput {
  email: OrderByArg
  firstName: OrderByArg
  gender: OrderByArg
  id: OrderByArg
  lastName: OrderByArg
  wantsNewsletter: OrderByArg
  yearOfBirth: OrderByArg
}

type UserRole {
  id: String!
}

input UserRoleCreateInput {
  id: String!
  users: UserCreateManyWithoutRolesInput
}

input UserRoleCreateManyWithoutUsersInput {
  connect: [UserRoleWhereUniqueInput!]
  create: [UserRoleCreateWithoutUsersInput!]
}

input UserRoleCreateWithoutUsersInput {
  id: String!
}

input UserRoleFilter {
  every: UserRoleWhereInput
  none: UserRoleWhereInput
  some: UserRoleWhereInput
}

input UserRoleOrderByInput {
  id: OrderByArg
}

input UserRoleScalarWhereInput {
  AND: [UserRoleScalarWhereInput!]
  id: StringFilter
  NOT: [UserRoleScalarWhereInput!]
  OR: [UserRoleScalarWhereInput!]
  users: UserFilter
}

input UserRoleUpdateInput {
  id: String
  users: UserUpdateManyWithoutRolesInput
}

input UserRoleUpdateManyDataInput {
  id: String
}

input UserRoleUpdateManyMutationInput {
  id: String
}

input UserRoleUpdateManyWithoutUsersInput {
  connect: [UserRoleWhereUniqueInput!]
  create: [UserRoleCreateWithoutUsersInput!]
  delete: [UserRoleWhereUniqueInput!]
  deleteMany: [UserRoleScalarWhereInput!]
  disconnect: [UserRoleWhereUniqueInput!]
  set: [UserRoleWhereUniqueInput!]
  update: [UserRoleUpdateWithWhereUniqueWithoutUsersInput!]
  updateMany: [UserRoleUpdateManyWithWhereNestedInput!]
  upsert: [UserRoleUpsertWithWhereUniqueWithoutUsersInput!]
}

input UserRoleUpdateManyWithWhereNestedInput {
  data: UserRoleUpdateManyDataInput!
  where: UserRoleScalarWhereInput!
}

input UserRoleUpdateWithoutUsersDataInput {
  id: String
}

input UserRoleUpdateWithWhereUniqueWithoutUsersInput {
  data: UserRoleUpdateWithoutUsersDataInput!
  where: UserRoleWhereUniqueInput!
}

input UserRoleUpsertWithWhereUniqueWithoutUsersInput {
  create: UserRoleCreateWithoutUsersInput!
  update: UserRoleUpdateWithoutUsersDataInput!
  where: UserRoleWhereUniqueInput!
}

input UserRoleWhereInput {
  AND: [UserRoleWhereInput!]
  id: StringFilter
  NOT: [UserRoleWhereInput!]
  OR: [UserRoleWhereInput!]
  users: UserFilter
}

input UserRoleWhereUniqueInput {
  id: String
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  email: StringFilter
  firstName: NullableStringFilter
  gender: Gender
  id: UUIDFilter
  lastName: NullableStringFilter
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  roles: UserRoleFilter
  wantsNewsletter: BooleanFilter
  yearOfBirth: NullableIntFilter
}

input UserUpdateInput {
  email: String
  firstName: String
  gender: Gender
  id: String
  lastName: String
  roles: UserRoleUpdateManyWithoutUsersInput
  wantsNewsletter: Boolean
  yearOfBirth: Int
}

input UserUpdateManyDataInput {
  email: String
  firstName: String
  gender: Gender
  id: String
  lastName: String
  wantsNewsletter: Boolean
  yearOfBirth: Int
}

input UserUpdateManyMutationInput {
  email: String
  firstName: String
  gender: Gender
  id: String
  lastName: String
  wantsNewsletter: Boolean
  yearOfBirth: Int
}

input UserUpdateManyWithoutRolesInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutRolesInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutRolesInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutRolesInput!]
}

input UserUpdateManyWithWhereNestedInput {
  data: UserUpdateManyDataInput!
  where: UserScalarWhereInput!
}

input UserUpdateWithoutRolesDataInput {
  email: String
  firstName: String
  gender: Gender
  id: String
  lastName: String
  wantsNewsletter: Boolean
  yearOfBirth: Int
}

input UserUpdateWithWhereUniqueWithoutRolesInput {
  data: UserUpdateWithoutRolesDataInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithWhereUniqueWithoutRolesInput {
  create: UserCreateWithoutRolesInput!
  update: UserUpdateWithoutRolesDataInput!
  where: UserWhereUniqueInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  email: StringFilter
  firstName: NullableStringFilter
  gender: Gender
  id: UUIDFilter
  lastName: NullableStringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  roles: UserRoleFilter
  wantsNewsletter: BooleanFilter
  yearOfBirth: NullableIntFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
}

scalar UUID

input UUIDFilter {
  contains: UUID
  endsWith: UUID
  equals: UUID
  gt: UUID
  gte: UUID
  in: [UUID!]
  lt: UUID
  lte: UUID
  not: UUID
  notIn: [UUID!]
  startsWith: UUID
}
