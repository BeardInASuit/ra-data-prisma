### This file was generated by Nexus Schema
### Do not make changes to this file directly


type BatchPayload {
  count: Int!
}

type BlogPost {
  author: User
  comments(cursor: BlogPostCommentWhereUniqueInput, skip: Int, take: Int): [BlogPostComment!]!
  id: String!
  text: String!
  title: String!
}

type BlogPostComment {
  author: User
  id: String!
  post: BlogPost
  text: String!
}

input BlogPostCommentCreateInput {
  author: UserCreateOneWithoutCommentsInput
  id: String
  post: BlogPostCreateOneWithoutCommentsInput
  text: String!
}

input BlogPostCommentCreateManyWithoutAuthorInput {
  connect: [BlogPostCommentWhereUniqueInput!]
  create: [BlogPostCommentCreateWithoutAuthorInput!]
}

input BlogPostCommentCreateManyWithoutPostInput {
  connect: [BlogPostCommentWhereUniqueInput!]
  create: [BlogPostCommentCreateWithoutPostInput!]
}

input BlogPostCommentCreateWithoutAuthorInput {
  id: String
  post: BlogPostCreateOneWithoutCommentsInput
  text: String!
}

input BlogPostCommentCreateWithoutPostInput {
  author: UserCreateOneWithoutCommentsInput
  id: String
  text: String!
}

input BlogPostCommentFilter {
  every: BlogPostCommentWhereInput
  none: BlogPostCommentWhereInput
  some: BlogPostCommentWhereInput
}

input BlogPostCommentOrderByInput {
  authorId: OrderByArg
  id: OrderByArg
  postId: OrderByArg
  text: OrderByArg
}

input BlogPostCommentScalarWhereInput {
  AND: [BlogPostCommentScalarWhereInput!]
  authorId: NullableStringFilter
  id: UUIDFilter
  NOT: [BlogPostCommentScalarWhereInput!]
  OR: [BlogPostCommentScalarWhereInput!]
  postId: NullableStringFilter
  text: StringFilter
}

input BlogPostCommentUpdateInput {
  author: UserUpdateOneWithoutCommentsInput
  id: String
  post: BlogPostUpdateOneWithoutCommentsInput
  text: String
}

input BlogPostCommentUpdateManyDataInput {
  id: String
  text: String
}

input BlogPostCommentUpdateManyMutationInput {
  id: String
  text: String
}

input BlogPostCommentUpdateManyWithoutAuthorInput {
  connect: [BlogPostCommentWhereUniqueInput!]
  create: [BlogPostCommentCreateWithoutAuthorInput!]
  delete: [BlogPostCommentWhereUniqueInput!]
  deleteMany: [BlogPostCommentScalarWhereInput!]
  disconnect: [BlogPostCommentWhereUniqueInput!]
  set: [BlogPostCommentWhereUniqueInput!]
  update: [BlogPostCommentUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [BlogPostCommentUpdateManyWithWhereNestedInput!]
  upsert: [BlogPostCommentUpsertWithWhereUniqueWithoutAuthorInput!]
}

input BlogPostCommentUpdateManyWithoutPostInput {
  connect: [BlogPostCommentWhereUniqueInput!]
  create: [BlogPostCommentCreateWithoutPostInput!]
  delete: [BlogPostCommentWhereUniqueInput!]
  deleteMany: [BlogPostCommentScalarWhereInput!]
  disconnect: [BlogPostCommentWhereUniqueInput!]
  set: [BlogPostCommentWhereUniqueInput!]
  update: [BlogPostCommentUpdateWithWhereUniqueWithoutPostInput!]
  updateMany: [BlogPostCommentUpdateManyWithWhereNestedInput!]
  upsert: [BlogPostCommentUpsertWithWhereUniqueWithoutPostInput!]
}

input BlogPostCommentUpdateManyWithWhereNestedInput {
  data: BlogPostCommentUpdateManyDataInput!
  where: BlogPostCommentScalarWhereInput!
}

input BlogPostCommentUpdateWithoutAuthorDataInput {
  id: String
  post: BlogPostUpdateOneWithoutCommentsInput
  text: String
}

input BlogPostCommentUpdateWithoutPostDataInput {
  author: UserUpdateOneWithoutCommentsInput
  id: String
  text: String
}

input BlogPostCommentUpdateWithWhereUniqueWithoutAuthorInput {
  data: BlogPostCommentUpdateWithoutAuthorDataInput!
  where: BlogPostCommentWhereUniqueInput!
}

input BlogPostCommentUpdateWithWhereUniqueWithoutPostInput {
  data: BlogPostCommentUpdateWithoutPostDataInput!
  where: BlogPostCommentWhereUniqueInput!
}

input BlogPostCommentUpsertWithWhereUniqueWithoutAuthorInput {
  create: BlogPostCommentCreateWithoutAuthorInput!
  update: BlogPostCommentUpdateWithoutAuthorDataInput!
  where: BlogPostCommentWhereUniqueInput!
}

input BlogPostCommentUpsertWithWhereUniqueWithoutPostInput {
  create: BlogPostCommentCreateWithoutPostInput!
  update: BlogPostCommentUpdateWithoutPostDataInput!
  where: BlogPostCommentWhereUniqueInput!
}

input BlogPostCommentWhereInput {
  AND: [BlogPostCommentWhereInput!]
  author: UserWhereInput
  authorId: NullableStringFilter
  id: UUIDFilter
  NOT: [BlogPostCommentWhereInput!]
  OR: [BlogPostCommentWhereInput!]
  post: BlogPostWhereInput
  postId: NullableStringFilter
  text: StringFilter
}

input BlogPostCommentWhereUniqueInput {
  id: String
}

input BlogPostCreateInput {
  author: UserCreateOneWithoutBlogPostsInput
  comments: BlogPostCommentCreateManyWithoutPostInput
  id: String
  text: String!
  title: String!
}

input BlogPostCreateManyWithoutAuthorInput {
  connect: [BlogPostWhereUniqueInput!]
  create: [BlogPostCreateWithoutAuthorInput!]
}

input BlogPostCreateOneWithoutCommentsInput {
  connect: BlogPostWhereUniqueInput
  create: BlogPostCreateWithoutCommentsInput
}

input BlogPostCreateWithoutAuthorInput {
  comments: BlogPostCommentCreateManyWithoutPostInput
  id: String
  text: String!
  title: String!
}

input BlogPostCreateWithoutCommentsInput {
  author: UserCreateOneWithoutBlogPostsInput
  id: String
  text: String!
  title: String!
}

input BlogPostFilter {
  every: BlogPostWhereInput
  none: BlogPostWhereInput
  some: BlogPostWhereInput
}

input BlogPostOrderByInput {
  authorId: OrderByArg
  id: OrderByArg
  text: OrderByArg
  title: OrderByArg
}

input BlogPostScalarWhereInput {
  AND: [BlogPostScalarWhereInput!]
  authorId: NullableStringFilter
  comments: BlogPostCommentFilter
  id: UUIDFilter
  NOT: [BlogPostScalarWhereInput!]
  OR: [BlogPostScalarWhereInput!]
  text: StringFilter
  title: StringFilter
}

input BlogPostUpdateInput {
  author: UserUpdateOneWithoutBlogPostsInput
  comments: BlogPostCommentUpdateManyWithoutPostInput
  id: String
  text: String
  title: String
}

input BlogPostUpdateManyDataInput {
  id: String
  text: String
  title: String
}

input BlogPostUpdateManyMutationInput {
  id: String
  text: String
  title: String
}

input BlogPostUpdateManyWithoutAuthorInput {
  connect: [BlogPostWhereUniqueInput!]
  create: [BlogPostCreateWithoutAuthorInput!]
  delete: [BlogPostWhereUniqueInput!]
  deleteMany: [BlogPostScalarWhereInput!]
  disconnect: [BlogPostWhereUniqueInput!]
  set: [BlogPostWhereUniqueInput!]
  update: [BlogPostUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [BlogPostUpdateManyWithWhereNestedInput!]
  upsert: [BlogPostUpsertWithWhereUniqueWithoutAuthorInput!]
}

input BlogPostUpdateManyWithWhereNestedInput {
  data: BlogPostUpdateManyDataInput!
  where: BlogPostScalarWhereInput!
}

input BlogPostUpdateOneWithoutCommentsInput {
  connect: BlogPostWhereUniqueInput
  create: BlogPostCreateWithoutCommentsInput
  delete: Boolean
  disconnect: Boolean
  update: BlogPostUpdateWithoutCommentsDataInput
  upsert: BlogPostUpsertWithoutCommentsInput
}

input BlogPostUpdateWithoutAuthorDataInput {
  comments: BlogPostCommentUpdateManyWithoutPostInput
  id: String
  text: String
  title: String
}

input BlogPostUpdateWithoutCommentsDataInput {
  author: UserUpdateOneWithoutBlogPostsInput
  id: String
  text: String
  title: String
}

input BlogPostUpdateWithWhereUniqueWithoutAuthorInput {
  data: BlogPostUpdateWithoutAuthorDataInput!
  where: BlogPostWhereUniqueInput!
}

input BlogPostUpsertWithoutCommentsInput {
  create: BlogPostCreateWithoutCommentsInput!
  update: BlogPostUpdateWithoutCommentsDataInput!
}

input BlogPostUpsertWithWhereUniqueWithoutAuthorInput {
  create: BlogPostCreateWithoutAuthorInput!
  update: BlogPostUpdateWithoutAuthorDataInput!
  where: BlogPostWhereUniqueInput!
}

input BlogPostWhereInput {
  AND: [BlogPostWhereInput!]
  author: UserWhereInput
  authorId: NullableStringFilter
  comments: BlogPostCommentFilter
  id: UUIDFilter
  NOT: [BlogPostWhereInput!]
  OR: [BlogPostWhereInput!]
  text: StringFilter
  title: StringFilter
}

input BlogPostWhereUniqueInput {
  id: String
}

input BooleanFilter {
  equals: Boolean
  not: Boolean
}

enum Gender {
  FEMALE
  MALE
  OTHER
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

type Mutation {
  createOneBlogPost(data: BlogPostCreateInput!): BlogPost!
  createOneBlogPostComment(data: BlogPostCommentCreateInput!): BlogPostComment!
  createOneSomePublicRecordWithIntId(data: SomePublicRecordWithIntIdCreateInput!): SomePublicRecordWithIntId!
  createOneUser(data: UserCreateInput!): User!
  createOneUserRole(data: UserRoleCreateInput!): UserRole!
  deleteManyBlogPost(where: BlogPostWhereInput): BatchPayload!
  deleteManyBlogPostComment(where: BlogPostCommentWhereInput): BatchPayload!
  deleteManySomePublicRecordWithIntId(where: SomePublicRecordWithIntIdWhereInput): BatchPayload!
  deleteManyUser(where: UserWhereInput): BatchPayload!
  deleteManyUserRole(where: UserRoleWhereInput): BatchPayload!
  deleteOneBlogPost(where: BlogPostWhereUniqueInput!): BlogPost
  deleteOneBlogPostComment(where: BlogPostCommentWhereUniqueInput!): BlogPostComment
  deleteOneSomePublicRecordWithIntId(where: SomePublicRecordWithIntIdWhereUniqueInput!): SomePublicRecordWithIntId
  deleteOneUser(where: UserWhereUniqueInput!): User
  deleteOneUserRole(where: UserRoleWhereUniqueInput!): UserRole
  updateManyBlogPost(data: BlogPostUpdateManyMutationInput!, where: BlogPostWhereInput): BatchPayload!
  updateManyBlogPostComment(data: BlogPostCommentUpdateManyMutationInput!, where: BlogPostCommentWhereInput): BatchPayload!
  updateManySomePublicRecordWithIntId(data: SomePublicRecordWithIntIdUpdateManyMutationInput!, where: SomePublicRecordWithIntIdWhereInput): BatchPayload!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updateManyUserRole(data: UserRoleUpdateManyMutationInput!, where: UserRoleWhereInput): BatchPayload!
  updateOneBlogPost(data: BlogPostUpdateInput!, where: BlogPostWhereUniqueInput!): BlogPost
  updateOneBlogPostComment(data: BlogPostCommentUpdateInput!, where: BlogPostCommentWhereUniqueInput!): BlogPostComment
  updateOneSomePublicRecordWithIntId(data: SomePublicRecordWithIntIdUpdateInput!, where: SomePublicRecordWithIntIdWhereUniqueInput!): SomePublicRecordWithIntId
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateOneUserRole(data: UserRoleUpdateInput!, where: UserRoleWhereUniqueInput!): UserRole
  upsertOneBlogPost(create: BlogPostCreateInput!, update: BlogPostUpdateInput!, where: BlogPostWhereUniqueInput!): BlogPost!
  upsertOneBlogPostComment(create: BlogPostCommentCreateInput!, update: BlogPostCommentUpdateInput!, where: BlogPostCommentWhereUniqueInput!): BlogPostComment!
  upsertOneSomePublicRecordWithIntId(create: SomePublicRecordWithIntIdCreateInput!, update: SomePublicRecordWithIntIdUpdateInput!, where: SomePublicRecordWithIntIdWhereUniqueInput!): SomePublicRecordWithIntId!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  upsertOneUserRole(create: UserRoleCreateInput!, update: UserRoleUpdateInput!, where: UserRoleWhereUniqueInput!): UserRole!
}

input NullableIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

enum OrderByArg {
  asc
  desc
}

type Query {
  blogPost(where: BlogPostWhereUniqueInput!): BlogPost
  blogPostComment(where: BlogPostCommentWhereUniqueInput!): BlogPostComment
  blogPostComments(cursor: BlogPostCommentWhereUniqueInput, orderBy: BlogPostCommentOrderByInput, skip: Int, take: Int, where: BlogPostCommentWhereInput): [BlogPostComment!]!
  blogPostCommentsCount(cursor: BlogPostCommentWhereUniqueInput, orderBy: BlogPostCommentOrderByInput, skip: Int, take: Int, where: BlogPostCommentWhereInput): Int!
  blogPosts(cursor: BlogPostWhereUniqueInput, orderBy: BlogPostOrderByInput, skip: Int, take: Int, where: BlogPostWhereInput): [BlogPost!]!
  blogPostsCount(cursor: BlogPostWhereUniqueInput, orderBy: BlogPostOrderByInput, skip: Int, take: Int, where: BlogPostWhereInput): Int!
  somePublicRecordWithIntId(where: SomePublicRecordWithIntIdWhereUniqueInput!): SomePublicRecordWithIntId
  somePublicRecordWithIntIds(cursor: SomePublicRecordWithIntIdWhereUniqueInput, orderBy: SomePublicRecordWithIntIdOrderByInput, skip: Int, take: Int, where: SomePublicRecordWithIntIdWhereInput): [SomePublicRecordWithIntId!]!
  somePublicRecordWithIntIdsCount(cursor: SomePublicRecordWithIntIdWhereUniqueInput, orderBy: SomePublicRecordWithIntIdOrderByInput, skip: Int, take: Int, where: SomePublicRecordWithIntIdWhereInput): Int!
  user(where: UserWhereUniqueInput!): User
  userRole(where: UserRoleWhereUniqueInput!): UserRole
  userRoles(cursor: UserRoleWhereUniqueInput, orderBy: UserRoleOrderByInput, skip: Int, take: Int, where: UserRoleWhereInput): [UserRole!]!
  userRolesCount(cursor: UserRoleWhereUniqueInput, orderBy: UserRoleOrderByInput, skip: Int, take: Int, where: UserRoleWhereInput): Int!
  users(cursor: UserWhereUniqueInput, orderBy: UserOrderByInput, skip: Int, take: Int, where: UserWhereInput): [User!]!
  usersCount(cursor: UserWhereUniqueInput, orderBy: UserOrderByInput, skip: Int, take: Int, where: UserWhereInput): Int!
}

type SomePublicRecordWithIntId {
  id: Int!
  title: String!
}

input SomePublicRecordWithIntIdCreateInput {
  title: String!
}

input SomePublicRecordWithIntIdOrderByInput {
  id: OrderByArg
  title: OrderByArg
}

input SomePublicRecordWithIntIdUpdateInput {
  id: Int
  title: String
}

input SomePublicRecordWithIntIdUpdateManyMutationInput {
  id: Int
  title: String
}

input SomePublicRecordWithIntIdWhereInput {
  AND: [SomePublicRecordWithIntIdWhereInput!]
  id: IntFilter
  NOT: [SomePublicRecordWithIntIdWhereInput!]
  OR: [SomePublicRecordWithIntIdWhereInput!]
  title: StringFilter
}

input SomePublicRecordWithIntIdWhereUniqueInput {
  id: Int
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

enum Topic {
  TOPIC_ONE
  TOPIC_THREE
  TOPIC_TWO
}

type User {
  blogPosts(cursor: BlogPostWhereUniqueInput, skip: Int, take: Int): [BlogPost!]!
  comments(cursor: BlogPostCommentWhereUniqueInput, skip: Int, take: Int): [BlogPostComment!]!
  email: String!
  firstName: String
  gender: Gender
  id: String!
  interests: [Topic!]!
  lastName: String
  logs(from: String!, to: String!): [String!]!
  roles(cursor: UserRoleWhereUniqueInput, skip: Int, take: Int, where: UserRoleWhereInput): [UserRole!]!
  userSocialMedia: UserSocialMedia
  wantsNewsletter: Boolean!
  yearOfBirth: Int
}

input UserCreateInput {
  blogPosts: BlogPostCreateManyWithoutAuthorInput
  comments: BlogPostCommentCreateManyWithoutAuthorInput
  email: String!
  firstName: String
  gender: Gender
  id: String
  interests: UserCreateinterestsInput
  lastName: String
  roles: UserRoleCreateManyWithoutUsersInput
  userSocialMedia: UserSocialMediaCreateOneWithoutUserInput
  wantsNewsletter: Boolean!
  yearOfBirth: Int
}

input UserCreateinterestsInput {
  set: [Topic!]
}

input UserCreateManyWithoutRolesInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutRolesInput!]
}

input UserCreateOneWithoutBlogPostsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutBlogPostsInput
}

input UserCreateOneWithoutCommentsInput {
  connect: UserWhereUniqueInput
}

input UserCreateWithoutBlogPostsInput {
  comments: BlogPostCommentCreateManyWithoutAuthorInput
  email: String!
  firstName: String
  gender: Gender
  id: String
  interests: UserCreateinterestsInput
  lastName: String
  roles: UserRoleCreateManyWithoutUsersInput
  userSocialMedia: UserSocialMediaCreateOneWithoutUserInput
  wantsNewsletter: Boolean!
  yearOfBirth: Int
}

input UserCreateWithoutCommentsInput {
  blogPosts: BlogPostCreateManyWithoutAuthorInput
  email: String!
  firstName: String
  gender: Gender
  id: String
  interests: UserCreateinterestsInput
  lastName: String
  roles: UserRoleCreateManyWithoutUsersInput
  userSocialMedia: UserSocialMediaCreateOneWithoutUserInput
  wantsNewsletter: Boolean!
  yearOfBirth: Int
}

input UserCreateWithoutRolesInput {
  blogPosts: BlogPostCreateManyWithoutAuthorInput
  comments: BlogPostCommentCreateManyWithoutAuthorInput
  email: String!
  firstName: String
  gender: Gender
  id: String
  interests: UserCreateinterestsInput
  lastName: String
  userSocialMedia: UserSocialMediaCreateOneWithoutUserInput
  wantsNewsletter: Boolean!
  yearOfBirth: Int
}

input UserFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

input UserOrderByInput {
  email: OrderByArg
  firstName: OrderByArg
  gender: OrderByArg
  id: OrderByArg
  lastName: OrderByArg
  wantsNewsletter: OrderByArg
  yearOfBirth: OrderByArg
}

type UserRole {
  id: String!
  name: String!
}

input UserRoleCreateInput {
  id: String
  name: String!
  users: UserCreateManyWithoutRolesInput
}

input UserRoleCreateManyWithoutUsersInput {
  connect: [UserRoleWhereUniqueInput!]
  create: [UserRoleCreateWithoutUsersInput!]
}

input UserRoleCreateWithoutUsersInput {
  id: String
  name: String!
}

input UserRoleFilter {
  every: UserRoleWhereInput
  none: UserRoleWhereInput
  some: UserRoleWhereInput
}

input UserRoleOrderByInput {
  id: OrderByArg
  name: OrderByArg
}

input UserRoleScalarWhereInput {
  AND: [UserRoleScalarWhereInput!]
  id: UUIDFilter
  name: StringFilter
  NOT: [UserRoleScalarWhereInput!]
  OR: [UserRoleScalarWhereInput!]
  users: UserFilter
}

input UserRoleUpdateInput {
  id: String
  name: String
  users: UserUpdateManyWithoutRolesInput
}

input UserRoleUpdateManyDataInput {
  id: String
  name: String
}

input UserRoleUpdateManyMutationInput {
  id: String
  name: String
}

input UserRoleUpdateManyWithoutUsersInput {
  connect: [UserRoleWhereUniqueInput!]
  create: [UserRoleCreateWithoutUsersInput!]
  delete: [UserRoleWhereUniqueInput!]
  deleteMany: [UserRoleScalarWhereInput!]
  disconnect: [UserRoleWhereUniqueInput!]
  set: [UserRoleWhereUniqueInput!]
  update: [UserRoleUpdateWithWhereUniqueWithoutUsersInput!]
  updateMany: [UserRoleUpdateManyWithWhereNestedInput!]
  upsert: [UserRoleUpsertWithWhereUniqueWithoutUsersInput!]
}

input UserRoleUpdateManyWithWhereNestedInput {
  data: UserRoleUpdateManyDataInput!
  where: UserRoleScalarWhereInput!
}

input UserRoleUpdateWithoutUsersDataInput {
  id: String
  name: String
}

input UserRoleUpdateWithWhereUniqueWithoutUsersInput {
  data: UserRoleUpdateWithoutUsersDataInput!
  where: UserRoleWhereUniqueInput!
}

input UserRoleUpsertWithWhereUniqueWithoutUsersInput {
  create: UserRoleCreateWithoutUsersInput!
  update: UserRoleUpdateWithoutUsersDataInput!
  where: UserRoleWhereUniqueInput!
}

input UserRoleWhereInput {
  AND: [UserRoleWhereInput!]
  id: UUIDFilter
  name: StringFilter
  NOT: [UserRoleWhereInput!]
  OR: [UserRoleWhereInput!]
  users: UserFilter
}

input UserRoleWhereUniqueInput {
  id: String
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  blogPosts: BlogPostFilter
  comments: BlogPostCommentFilter
  email: StringFilter
  firstName: NullableStringFilter
  gender: Gender
  id: UUIDFilter
  lastName: NullableStringFilter
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  roles: UserRoleFilter
  wantsNewsletter: BooleanFilter
  yearOfBirth: NullableIntFilter
}

type UserSocialMedia {
  id: String!
  instagram: String!
  twitter: String!
  user: User!
}

input UserSocialMediaCreateOneWithoutUserInput {
  connect: UserSocialMediaWhereUniqueInput
  create: UserSocialMediaCreateWithoutUserInput
}

input UserSocialMediaCreateWithoutUserInput {
  id: String
  instagram: String!
  twitter: String!
}

input UserSocialMediaUpdateOneWithoutUserInput {
  connect: UserSocialMediaWhereUniqueInput
  create: UserSocialMediaCreateWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  update: UserSocialMediaUpdateWithoutUserDataInput
  upsert: UserSocialMediaUpsertWithoutUserInput
}

input UserSocialMediaUpdateWithoutUserDataInput {
  id: String
  instagram: String
  twitter: String
}

input UserSocialMediaUpsertWithoutUserInput {
  create: UserSocialMediaCreateWithoutUserInput!
  update: UserSocialMediaUpdateWithoutUserDataInput!
}

input UserSocialMediaWhereInput {
  AND: [UserSocialMediaWhereInput!]
  id: UUIDFilter
  instagram: StringFilter
  NOT: [UserSocialMediaWhereInput!]
  OR: [UserSocialMediaWhereInput!]
  twitter: StringFilter
  user: UserWhereInput
  userId: StringFilter
}

input UserSocialMediaWhereUniqueInput {
  id: String
}

input UserUpdateInput {
  blogPosts: BlogPostUpdateManyWithoutAuthorInput
  comments: BlogPostCommentUpdateManyWithoutAuthorInput
  email: String
  firstName: String
  gender: Gender
  id: String
  interests: UserUpdateinterestsInput
  lastName: String
  roles: UserRoleUpdateManyWithoutUsersInput
  userSocialMedia: UserSocialMediaUpdateOneWithoutUserInput
  wantsNewsletter: Boolean
  yearOfBirth: Int
}

input UserUpdateinterestsInput {
  set: [Topic!]
}

input UserUpdateManyDataInput {
  email: String
  firstName: String
  gender: Gender
  id: String
  interests: UserUpdateinterestsInput
  lastName: String
  wantsNewsletter: Boolean
  yearOfBirth: Int
}

input UserUpdateManyMutationInput {
  email: String
  firstName: String
  gender: Gender
  id: String
  interests: UserUpdateinterestsInput
  lastName: String
  wantsNewsletter: Boolean
  yearOfBirth: Int
}

input UserUpdateManyWithoutRolesInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutRolesInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutRolesInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutRolesInput!]
}

input UserUpdateManyWithWhereNestedInput {
  data: UserUpdateManyDataInput!
  where: UserScalarWhereInput!
}

input UserUpdateOneWithoutBlogPostsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutBlogPostsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutBlogPostsDataInput
  upsert: UserUpsertWithoutBlogPostsInput
}

input UserUpdateOneWithoutCommentsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutCommentsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutCommentsDataInput
  upsert: UserUpsertWithoutCommentsInput
}

input UserUpdateWithoutBlogPostsDataInput {
  comments: BlogPostCommentUpdateManyWithoutAuthorInput
  email: String
  firstName: String
  gender: Gender
  id: String
  interests: UserUpdateinterestsInput
  lastName: String
  roles: UserRoleUpdateManyWithoutUsersInput
  userSocialMedia: UserSocialMediaUpdateOneWithoutUserInput
  wantsNewsletter: Boolean
  yearOfBirth: Int
}

input UserUpdateWithoutCommentsDataInput {
  blogPosts: BlogPostUpdateManyWithoutAuthorInput
  email: String
  firstName: String
  gender: Gender
  id: String
  interests: UserUpdateinterestsInput
  lastName: String
  roles: UserRoleUpdateManyWithoutUsersInput
  userSocialMedia: UserSocialMediaUpdateOneWithoutUserInput
  wantsNewsletter: Boolean
  yearOfBirth: Int
}

input UserUpdateWithoutRolesDataInput {
  blogPosts: BlogPostUpdateManyWithoutAuthorInput
  comments: BlogPostCommentUpdateManyWithoutAuthorInput
  email: String
  firstName: String
  gender: Gender
  id: String
  interests: UserUpdateinterestsInput
  lastName: String
  userSocialMedia: UserSocialMediaUpdateOneWithoutUserInput
  wantsNewsletter: Boolean
  yearOfBirth: Int
}

input UserUpdateWithWhereUniqueWithoutRolesInput {
  data: UserUpdateWithoutRolesDataInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithoutBlogPostsInput {
  create: UserCreateWithoutBlogPostsInput!
  update: UserUpdateWithoutBlogPostsDataInput!
}

input UserUpsertWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput!
  update: UserUpdateWithoutCommentsDataInput!
}

input UserUpsertWithWhereUniqueWithoutRolesInput {
  create: UserCreateWithoutRolesInput!
  update: UserUpdateWithoutRolesDataInput!
  where: UserWhereUniqueInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  blogPosts: BlogPostFilter
  comments: BlogPostCommentFilter
  email: StringFilter
  firstName: NullableStringFilter
  gender: Gender
  id: UUIDFilter
  lastName: NullableStringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  roles: UserRoleFilter
  userSocialMedia: UserSocialMediaWhereInput
  wantsNewsletter: BooleanFilter
  yearOfBirth: NullableIntFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
}

scalar UUID

input UUIDFilter {
  contains: UUID
  endsWith: UUID
  equals: UUID
  gt: UUID
  gte: UUID
  in: [UUID!]
  lt: UUID
  lte: UUID
  not: UUID
  notIn: [UUID!]
  startsWith: UUID
}
